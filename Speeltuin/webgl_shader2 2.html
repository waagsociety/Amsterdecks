<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - shaders [custom]</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #050505;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #ffffff;
			}

			#oldie a { color:#da0 }
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - shader material demo. featuring <a href="http://www.pouet.net/prod.php?which=52761" target="_blank">Monjori by Mic</a></div>

		
    <link rel="stylesheet" href="css/skeleton.css">
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/codemirror.css">
    <script src="js/lib/d3.v3.min.js" charset="utf-8"></script>
    <script src="js/lib/topojson.v1.min.js"></script>
    <script src="js/lib/three.min.js"></script>
    <script src="js/lib/TrackballControls.js"></script>
    <script src="js/lib/Detector.js"></script>
    <script src="js/lib/turf.min.js"></script>
    <script src="js/codemirror.js"></script>
    <script src="js/javascript.js"></script>
    <script src="js/geo.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		

		<script id="fragment_shader4" type="x-shader/x-fragment">

			uniform float time;
			uniform vec2 resolution;

			varying vec2 vUv;

			void main( void ) {

				vec2 position = -1.0 + 2.0 * vUv;

				float red = abs( sin( position.x * position.y + time / 5.0 ) );
				float green = abs( sin( position.x * position.y + time / 4.0 ) );
				float blue = abs( sin( position.x * position.y + time / 3.0 ) );
				gl_FragColor = vec4( red, green, blue, 1.0 );

			}

		</script>


		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
      var camera, controls, scene, renderer;
			var uniforms1, uniforms2;
			var clock = new THREE.Clock();

			// Store downloaded JSON in variable
      var json;

      var defaults = {
        url: 'data/water.amsterdam.json',
        color:
          'function(d) {\n' +
          '  return "rgb(0, 0, 140)"' +
          '}',
        height:
          'function(d) {\n' +
          '  return 2' +
          '}'
      };

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.z = 4;

				scene = new THREE.Scene();

				
        var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

				uniforms1 = {
					time: { type: "f", value: 1.0 },
					resolution: { type: "v2", value: new THREE.Vector2() }
				};

				var params = [
					['fragment_shader4', uniforms1]
				];

				for( var i = 0; i < params.length; i++ ) {

					var material = new THREE.ShaderMaterial( {

						uniforms: params[ i ][ 1 ],
						vertexShader: document.getElementById( 'vertexShader' ).textContent,
						fragmentShader: document.getElementById( params[ i ][ 0 ] ).textContent

						} );

					var mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );
				}

				
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
				container.appendChild( renderer.domElement );


				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );

			}
			
			







			function clearGroups() {
        if (json) {
          if (json.type === 'FeatureCollection') {
            json.features.forEach(function(feature) {
              scene.remove(feature._group);
            });
          } else if (json.type === 'Topology') {
            Object.keys(json.objects).forEach(function(key) {
              json.objects[key].geometries.forEach(function(object) {
                scene.remove(object._group);
              });
            });
          }
        }
        render();
      }

			function update() {
        clearGroups();

        var width = container.clientWidth;
        var height = container.clientHeight;

        // Read url from url textarea
        var url = "data/water.amsterdam.json";

        d3.json(url, function(data) {

          json = data;

          var functions = {};

         
          functions.color = eval('(' + defaults.color + ')');
					functions.height = eval('(' + defaults.height + ')');
          

          if (json.type === 'FeatureCollection') {

            var projection = getProjection(json, width, height);

            json.features.forEach(function(feature) {
              var group = addFeature(feature, projection, functions);
              feature._group = group;
            });

          } else if (json.type === 'Topology') {

            var geojson = topojson.merge(json, json.objects[Object.keys(json.objects)[0]].geometries);
            var projection = getProjection(geojson, width, height);

            Object.keys(json.objects).forEach(function(key) {
              json.objects[key].geometries.forEach(function(object) {
                var feature = topojson.feature(json, object);
                var group = addFeature(feature, projection, functions);
                object._group = group;
              });
            });

          } else {
            console.log('This tutorial only renders TopoJSON and GeoJSON FeatureCollections')
          }

          render();
        });
      }
			function addShape(group, shape, extrudeSettings, material, color, x, y, z, rx, ry, rz, s) {
        var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

        var mesh = new THREE.Mesh(geometry, material);

        // Add shadows
        mesh.castShadow = false;
        mesh.receiveShadow = false;

        mesh.position.set(x, y, z);
        mesh.rotation.set(rx, ry, rz);
        mesh.scale.set(s, s, s);
        group.add(mesh);
      }

      function addFeature(feature, projection, functions) {
        var group = new THREE.Group();
        scene.add(group);

        var color;
        var amount;

        try {
          color = functions.color(feature.properties);
        } catch(err) {
          console.log(err);
        }

        try {
          amount = functions.height(feature.properties);
        } catch(err) {
          console.log(err);
        }

        var extrudeSettings = {
          amount: 1,
          bevelEnabled: false
        };

        var material = 'phong';

        if (feature.geometry.type === 'Polygon') {
          var shape = createPolygonShape(feature.geometry.coordinates, projection);
          addShape(group, shape, extrudeSettings, material, color, 0, 0, amount, Math.PI, 0, 0, 1);
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach(function(polygon) {
            var shape = createPolygonShape(polygon, projection);
            addShape(group, shape, extrudeSettings, material, color, 0, 0, amount, Math.PI, 0, 0, 1);
          });
        } else {
          console.log('This tutorial only renders Polygons and MultiPolygons')
        }
        return group;
      }














			function onWindowResize( event ) {

				uniforms1.resolution.value.x = window.innerWidth;
				uniforms1.resolution.value.y = window.innerHeight;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

      window.onhashchange = function() {
        if (!disableHashChange) {
          parseHash(location.hash.substring(1))
        }
      };

      if (location.hash) {
        parseHash(location.hash.substring(1));
      }

			//

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {

				var delta = clock.getDelta();

				uniforms1.time.value += delta * 5;

				for ( var i = 0; i < scene.children.length; i ++ ) {

					var object = scene.children[ i ];

					object.rotation.y += delta * 0.5 * ( i % 2 ? 1 : -1 );
					object.rotation.x += delta * 0.5 * ( i % 2 ? -1 : 1 );

				}

				renderer.render( scene, camera );

			}

			init();
			animate();

		</script>

	</body>
</html>
